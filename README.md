# pr-reviewer-assignment
Микроервис для назначения ревьюверов для Pull Request'ов. 

Сделано согласно [заданию](docs/Backend-trainee-assignment-autumn-2025.md). API можно посмотреть [здесь](api/openapi.yml).

## Инструкция по запуску
Есть [Makefile](Makefile) с разными командами. Поднять докер можно написав:
```sh
make up
```
или
```sh
docker-compose up
```
Перед этим нужно написать нужные переменные окружения в `.env` файле, [пример файла](example.env). Для корректного функционирования с докером достаточно скопировать пример в файл `.env`.

Сервис будет доступен на порту 8080.

## Общее описание
### Архитектурные особенности
Сервис написан по принципам Clean architecture и разделен по слоям. Благодаря этому можно легко расширять функционал и тестировать его.

Также был написан Graceful shutdown.

Используется паттерн Repository для абстракции над базой данных, также это позволит легко реализовать поддержку других баз данных.

### Использованные технологии и библиотеки
**PostgreSQL** - база данных.

**Docker** - для запуска сервиса с базой данных.

**oapi-codegen** - для конвертации OpenAPI спецификации в код.

**chi** - для HTTP-маршрутизации.

**pgx** - для работы с PostgreSQL в Go.

**Squirrel** - для генерации SQL запросов.

**golang-migrate/migrate** - для миграций БД.

**Logrus** - для структурирированного логирования.

**golangci-lint** - линтер для соблюдения код стайла.

## Миграции
Миграции лежат в папке [migrations](migrations).

Уже написанные миграции:
* 0001: создает таблицы и типы
* 0002: создает триггер который обновляет `merged_at` при merge Pull Request'а.
* 0003: создает индексы для оптимизации запросов.

## Code style
Конфигурация линтера в файле [.golangci.yaml](.golangci.yaml).
Запустить линтер можно написав:
```sh
make linter-golangci
```

## Допущения и решения
1. Может ли пользователь быть в нескольких командах одновременно?

Так как схема `User` предполагает, что у пользователя есть поле `team_name` и например при запросе в `/users/setIsActive` с телом 
```json
{
  "user_id": "u2",
  "is_active": false
}
```
предполагается ответ:
```json
{
  "user": {
    "user_id": "u2",
    "username": "Bob",
    "team_name": "backend",
    "is_active": false
  }
}
```
то есть предполагается функциональная зависимость `user_id => team_name`. 

Я решил, что пользователь может быть только в одной команде и реализовал именно так. Из-за этого например, при создании новой команды с пользователем который уже состоит в команде его команда меняется. То есть он переходит в новую команду из старой.

2. Нужно ли возвращать ошибку если приходит запрос на список PR'ов несуществующего пользователя (`/users/getReview`)?

Так как в спецификации API написано, что response бывает только со статусом 200, я решил вместо ошибки возвращать пустой список.